// Memory Map:
//	i			equ 0x000
//	j			equ 0x001
//	k			equ 0x002
//	l			equ 0x003
//     	sw_prescale		equ 0x004
//      IRQ_SAVE_WREG		equ 0x005
//      IRQ_SAVE_ZC		equ 0x006
//      IRQ_SAVE_INDA		equ 0x007
//      IRQ_TEMP0		equ 0x008
//      IRQ_TEMP1		equ 0x009
//	MAIN_TEMP_0		equ 0x00D
//	MAIN_TEMP_1		equ 0x00E
//	ADD_TEMP_0		equ 0x00F
//	STACKPTR		equ 0x1FF
//	WREG			equ 0x200
//	CARRY			equ 0x201
//	ZERO			equ 0x202
//	INDV			equ 0x203
//	INDA			equ 0x204
//	IRQ			equ 0x205
//      SW			equ 0x300
//      SW_dir			equ 0x301
//      SW_irq_en		equ 0x302
//      SW_irq			equ 0x303
//      LEDR			equ 0x304
//      LEDR_dir		equ 0x305
//      LEDR_irq_en		equ 0x306
//      LEDR_irq		equ 0x307
//      TIMER_0_count		equ 0x308
//      TIMER_0_period		equ 0x309
//      TIMER_0_control		equ 0x30A
//      TIMER_0_status		equ 0x30B
//
// Program Map:
//	RESET 			equ 0x000
//	INTERRUPT_VECTOR 	equ 0x004
//	STARTUP 		equ 0x005
//	MAIN			equ 0x010
//	MAIN_ADD_RETURN		equ 0x020
//	MAIN_I_SIGN_NEG		equ 0x041
//	MAIN_I_SIGN_END		equ 0x042
//	MAIN_WHILE_LOOP		equ 0x050
//	MAIN_WHILE_LOOP_END	equ 0x056
//	MAIN_SW_LOOP		equ 0x071
//	MAIN_SW_LOOP_END	equ 0x077
//	MAIN_FOREVER_LOOP	equ 0x07E
//	END_OF_PROGRAM		equ 0x07F
//	ADD			equ 0x080
//	__IRQ			equ 0x098
//	__IRQ_PRE		equ 0x0B0
//	__IRQ_SW		equ 0x0B2
//	__IRQ_RESTORE		equ 0x0D4
//
// Literal Map:
//	IRQ_EN_OFFSET		equ 1
//	m			equ 1
//	M			equ 1
//      TMR0_CTL_PRE_MASK	equ 0xff00
//      TMR0_CTL_PRE_OFFSET	equ 8
//      TMR0_CTL_IRQEN_OFFSET	equ 2
//      TMR0_CTL_RELOAD_OFFSET	equ 1
//      TMR0_CTL_RUN_OFFSET	equ 0
//	w			equ 0
//	W			equ 0

// Hand assembled
// Format is Instr_code[15:12],Dest[11],Literal[10:0]
//	STACKPTR equ 0x1FF
//
//      IRQ_SAVE_WREG equ 0x0005
//      IRQ_SAVE_ZC   equ 0x0006
//      IRQ_SAVE_INDA equ 0x0007
//
//      IRQ_TEMP0 equ 0x0008
//      IRQ_TEMP1 equ 0x0009
//
//	WREG equ 0x200  // W Register
//	CARRY equ 0x201  // Carry Register
//	ZERO equ 0x202  // Zero Register
//	INDV equ 0x203  // Indirect Value Register
//	INDA equ 0x204  // Indirect Pointer Register
//	IRQ equ 0x205	// Interrupt Control Register
//
//	W equ 0
//	w equ 0
//	M equ 1
//	m equ 1
//
//      TMR0_CTL_PRE_MASK equ 0xff00
//      TMR0_CTL_PRE_OFFSET equ 8
//      TMR0_CTL_IRQEN_OFFSET equ 2
//      TMR0_CTL_RELOAD_OFFSET equ 1
//      TMR0_CTL_RUN_OFFSET equ 0
//
//	IRQ_EN_OFFSET equ 1
//
//      SW equ 0x300
//      SW_dir equ 0x301
//      SW_irq_en equ 0x302
//      SW_irq equ 0x303
//
//      LEDR equ 0x304
//      LEDR_dir equ 0x305
//      LEDR_irq_en equ 0x306
//      LEDR_irq equ 0x307
//
//      TIMER_0_count equ 0x308
//      TIMER_0_period equ 0x309
//      TIMER_0_control equ 0x30A
//      TIMER_0_status equ 0x30B
//
//	ORG 0x0000
//0000	RESET: gol STARTUP
// gol STARTUP => gol 0x005 => C,0,0x005
C005

// All memory that's addressed must be defined
// can't use xxxx, so just make it a GOTO RESET
//0001
C000
//0002
C000
//0003
C000

//0004	ORG 0x0004
//0004  INTERRUPT_VECTOR: gol __IRQ
C098

//	// I could have put the IRQ function here, but didn't want to renumber everthing in program.mem
//
//0005	ORG 0x0005
//0005	STARTUP:
//	// initialize stack
//0005		mlw (STACKPTR - 1)  // 0x1FE is top of stack
21FE
//0006		mwm STACKPTR
11FF
//	//int i = 0;
//		i equ 0x0000
//0007		mlw .0
2000
//0008		mwm i
1000
//
//	//int j = 20;
//		j equ 0x0001
//0009		mlw .20
2014

//000A		mwm j
1001

//
//	//int k = 0;
//		k equ 0x0002
//000B		mlw .0
2000

//000C		mwm k
1002

//
//	//int l[10];
//		l equ 0x0003
//		l_end equ (l + 10 - 1) // l_end = 0x000C
//
//      // uint16_t sw_prescale;
//      sw_prescale equ 0x0004
//      mlw 0

//000D
2000
//      mwm sw_prescale
//000E
1004
//
//	//void main(void) {
//000F		gol MAIN
C010

//0010	ORG 0x0010
//0010	MAIN:
//	//  for (i = 0; i < 10; i++) {
//	//    l[i] = add(&j, i);
//	//  }
//		MAIN_TEMP_0 equ 0x000D
//		MAIN_TEMP_1 equ 0x000E
//0010		mm STACKPTR,w // get top of stack
01FF
//0011		mwm MAIN_TEMP_0 // save original stack position
100D
//0012		mwm INDA  // point the Indirect access at the stack
1204
//0013		mlw MAIN_ADD_RETURN // return address
2020
//0014		mwm INDV
1203
//0015		mlw .1
2001
//0016		sub INDA,M // next stack address
9A04
//		// load args right to left
//0017		mm i,w
0000
//0018		mwm INDV
1203
//0019		mlw .1
2001
//001A		sub INDA,M // next stack address
9A04
//001B		mlw j // &j
2001
//001C		mwm INDV
1203
//001D		mm INDA,w
0204
//001E		mwm STACKPTR
11FF
//001F		gol ADD
C080
//
//0020	MAIN_ADD_RETURN:
//0020		mm STACKPTR,w
01FF
//0021		mwm INDA
1204
//0022		mm INDV,w  // load return value
0203
//0023		mwm MAIN_TEMP_1  // save return value
100E
//0024		mm MAIN_TEMP_0,w // load previous STACKPTR value
000D
//0025		mwm STACKPTR  // "pop" function args off stack
11FF
//0026		mlw l
2003
//0027		mwm INDA
1204
//0028		mm i,w
0000
//0029		add INDA,m
8A04
//002A		mm MAIN_TEMP_1,w
000D
//002B		mwm INDV
1203
//
//		// i < 10 ?
//002C		mlw .1
2001
//002D		add i,m
8800
//002E		mlw .10
200A
//002F		sub i,w
9000
//0030		sms CARRY  // skip if carry set
A201
//0031		gol MAIN  // i < 10
C010
//
//		// out of for loop
//	//  i = i - j;
//0032		mm j,w
0001
//0033		sub i,m
9800
//
//	//  if (i >= 10) {
//	//    j = 0xaa;
//	//  } else {
//	//    j = 0x55;
//	//  }
//0034		mlw .10
200A
//0035		mwm MAIN_TEMP_1  // safe to reuse
100E
//0036		rlm i,w
3000
//0037		smc CARRY // If carry set, number is negative
B201
//		// borrow check doesn't work with mixed signs. Since
//		// 10 is a positive literal the "compiler" knows that if i is negative,
//		// i < 10
//0038		gol MAIN_I_SIGN_NEG
C041
//		
//0039		mm i,w
0000
//003A		sub MAIN_TEMP_1,w
900E
//003B		mlw 0x55  // assume not
2055
//003C		sms CARRY
A201
//003D		mlw 0xaa  // i > 10
20AA
//003E		smc ZERO
B202
//003F		mlw 0xaa // i == 10
20AA
//0040		gol MAIN_I_SIGN_END
C042
//
//	// If i is negative, it's obviously less than 10
//0041	MAIN_I_SIGN_NEG:
//0041		mlw 0x55
2055
//
//0042	MAIN_I_SIGN_END:
//0042		mwm j
1001
//
//	//  k = 0x55a9;
//0043		mlw (0x55a9 >> 5) // staying under sign ext.
22AD // 0x55AA >> 5 = 0x2AD
//0044		add k,m  // could use mwm, but we know the memory is zeroed, and this assures that carry is cleared in one op
8802
//0045		rlm k,m // 1
3802
//0046		rlm k,m // 2
3802
//0047		rlm k,m // 3
3802
//0048		rlm k,m // 4
3802
//0049		rlm k,m // 5
3802
//004A		mlw 0x9
2009
//004B		add k,m
8802
//
//	//  while ((j & k) != 0) {
//	//    k++;
//	//  }
//004C		mm k,w
0002
//004D		awm j,w
5001
//004E		smc ZERO
B202
//004F		gol MAIN_WHILE_LOOP_END // (j & k) == 0
C056
//0050	MAIN_WHILE_LOOP:
//0050		mlw .1
2001
//0051		add k,m
8802
//0052		mm k,w
0002
//0053		awm j,w
5001
//0054		sms ZERO
A202
//0055		gol MAIN_WHILE_LOOP
C050
//
//0056	MAIN_WHILE_LOOP_END:
//	//  i = (j | k) == -1;
//0056		mm k,w
0002
//0057		owm j,w
6001
//0058		mwm MAIN_TEMP_1
100E
//0059		mlw .-1
27FF
//005A		sub MAIN_TEMP_1,w
900E
//005B		mm ZERO,w  // if temp == -1, zero = 1, else 0
0202
//005C		mwm i;
1000
//
//	//  i = j > k;
//005D		mm j,w
0001
//005E		sub k,w  // CARRY clear if Wreg > Mem
9002
//005F		mlw 1  // assume true
2001
//0060		smc CARRY
B201
//0061		mlw 0
2000
//0062		mwm i
1000
//
//	//  i = j <= k;
//0063		mm j,w
0001
//0064		sub k,w  // CARRY set if Wreg <= Mem
9002
//0065		mm CARRY,w
0201
//0066		mwm i
1000

//	//  // Prep the Blinkenlitez
//	//  *SW_dir = 0x0000;      // All inputs
//	//  *SW_irq_en = 0x0000;   // No interrutps (for now)
//	//  *LEDR_irq_en = 0x0000; // no interrupts
//	//  *LEDR_dir = 0xFFFF;    // All outputs
//	//  *TIMER_0_period = 0xFFFF;
//	//
//	
//	    mlw 0
//0067
2000

//	    mwm SW_dir
//0068
1301

//	    mwm SW_irq_en
//0069
1302

//	    mwm LEDR_irq_en
//006A
1306

//	    mlw -1  // sign extend 0x7FF -> 0xFFFF
//006B
27FF

//	    mwm LEDR_dir
//006C
1305

//	    mwm TIMER_0_period
//006D
1309

//	
//	//  // Show off what we've got
//	//  // This sets the LEDR to the state of its SW
//	//  // set all SW high to exit first demo
//	//  while (*SW != 0xFFFF) {
//
//	    sub SW,w
//006E
9300

//	    smc ZERO  // Skip if Zero is clear (SW != 0xFFFF)
//006F
B202

//	    gol MAIN_SW_LOOP_END
//0070
C077

//	//    *LEDR = *SW;
//	//  }
//
//	MAIN_SW_LOOP:
//	    mm SW,w
//0071
0300

//	    mwm LEDR
//0072
1304

//	//  while (*SW != 0xFFFF) {
//
//	    mlw -1
//0073
27FF

//	    sub SW,w
//0074
9300

//	    sms ZERO  // Skip if Zero is set (SW == 0xFFFF)
//0075
A202

//	    gol MAIN_SW_LOOP
//0076
C071

//	MAIN_SW_LOOP_END:
//0077

//	//  // Prep counting blinkenlitez
//	//  *SW_irq_en = 0xFFFF; // Interupt on change
//	//  *TIMER_0_period = 0xFFFF;
//
//	    mlw -1
//0077
27FF

//	    mwm SW_irq_en
//0078
1302

//	    mwm TIMER_0_period
//0079
1309

//	//  *TIMER_0_control = (0xff << TMR0_CTL_PRE_OFFSET) |
//	//                     (1 << TMR0_CTL_IRQEN_OFFSET) |
//	//                     (1 << TMR0_CTL_IRQEN_OFFSET) | (1 << TMR0_CTL_RUN_OFFSET);
//
//	// optimized => *TIMER_0_control = 0xFF07
//
//	    mlw -249  // = 707 -> sign ext -> 0xFF07
//007A
2707

//	    mwm TIMER_0_control
//007B
130A

//	//  *IRQ = (1 << IRQ_EN_OFFSET); // Enable Interrupts
//
//		mlw 2
//007C
2002

//		mwm IRQ
//007D
1205

//	//  // Show counting blinkenlitez, see __irq
//	//  while (1) {
//	//  }
//
//	MAIN_FOREVER_LOOP:
//007E

//	    gol MAIN_FOREVER_LOOP
//007E
C07E

//	//}
//
//007F	END_OF_PROGRAM:
//007F		wfi // effectively a halt if there's no interrupt
E000
//			// and/or the interrupt handler just does rfi
//
//0080	ADD:
//	// return addr = *(STACKPTR + 2)
//	// by_ref = *(STACKPTR)
//	// by_val = *(STACKPTR + 1)
//	// return value = *(STACKPTR - 1)
//
//	//	int add(int *by_ref, int by_val) {
//		ADD_TEMP_0 equ 0x000F
//
//0080		mm STACKPTR,w
01FF
//0081		mwm INDA
1204
//0082		mlw .1
2001
//0083		add INDA,m  // by_val
8A04
//0084		mm INDV,w
0203
//0085		mwm ADD_TEMP_0 // by_val
100F
//0086		mm STACKPTR, w
01FF
//0087		mwm INDA,m  // by_ref
1204
//0088		mm INDV,w  // by_ref pointer value loaded in W
0203
//0089		mwm INDA  // by_ref pointer value loaded into indirect
1204
//008A		mm ADD_TEMP_0,w  // by_val
000F
//	//	  *by_ref = *by_ref + by_val;
//008B		add INDV,m
8A03
//
//	//	  return by_val;
//	//	}
//008C		mm STACKPTR,w
01FF
//008D		mwm INDA,m
1204
//008E		mlw .1
2001
//008F		sub INDA,m  // return value
9A04
//0090		mm ADD_TEMP_0,w
000F
//0091		mwm INDV
1203
//0092		mm INDA,w
0204
//0093		mwm STACKPTR // update STACKPTR
11FF
//0094		mlw .3
2003
//0095		add INDA,m  // return adress
8A04
//0096		mm INDV,w
0203
//0097		gow  // return
D000

//	__IRQ:
//0098

//	// void __attribute__((interrupt)) __irq(void) {
//
//	// SAVE STATE
//	    mwm IRQ_SAVE_WREG  // save WREG, ZERO/CARRY unaffected
//0098
1005

//	    mm ZERO,w  // ZERO set to value of ZERO, unaffected
//0099
0202

//	    mwm IRQ_SAVE_ZC
//009A
1006

//	    rlm IRQ_SAVE_ZC,m  // Rotate carry bit in
//009B
3806

//	//   // on timer interrupt decrement software prescaler, on zero update the
//	//   // count and increment the display
//	//   if (*TIMER_0_status != 0) {
//
//	    sms TIMER_0_status  // goto __IRQ_SW if TIMER_0_status == 0
//009C
A30B

//	    gol __IRQ_SW
//009D
C0B2

//	//     *TIMER_0_status = 0; // clear interrupt
//          mlw 0
//009E
2000

//          mwm TIMER_0_status
//009F
130B

//	//     if (sw_prescale == 0) {
//
//	    smc sw_prescale  // goto __IRQ_SW if sw_prescale != 0
//00A0
B004

//	    gol __IRQ_PRE
//00A1
C0B0

//	//       sw_prescale = (*SW >> 8) & 0xff;
//
//	    mm SW,w
//00A2
0300

//	    mwm sw_prescale
//00A3
1004

//	    rrm sw_prescale,m
//00A4
4804

//	    rrm sw_prescale,m
//00A5
4804

//	    rrm sw_prescale,m
//00A6
4804

//	    rrm sw_prescale,m
//00A7
4804

//	    rrm sw_prescale,m
//00A8
4804

//	    rrm sw_prescale,m
//00A9
4804

//	    rrm sw_prescale,m
//00AA
4804

//	    rrm sw_prescale,m  // everything rotated in is in upper 8 bits
//00AB
4804

//	    mlw 0xff
//00AC
20FF

//	    awm sw_prescale,m  // which gets masked out, so don't need to clear carry
//00AD
5804

//	                       // for logical shift
//
//	//       *LEDR++;
//
//	    mlw 1
//00AE
2001

//	    add LEDR,m
//00AF
8B04

//	//     }
//	//     sw_prescale--;
//
//	__IRQ_PRE
//00B0

//	    mlw 1
//00B0
2001

//	    sub sw_prescale,m
//00B1
9804

//	//   }
//
//	__IRQ_SW:
//00B2

//	//   if (*SW_irq != 0) {
//
//	    sms SW_irq  // goto __IRQ_RESTORE if SW_irq == 0
//00B2
A303

//	    gol __IRQ_RESTORE
//00B3
C0D4

//	//     *SW_irq = 0; // Clear all, doesn't matter how many changed, we'll update the
//	//                  // whole port
//
//	    mlw 0
//00B4
2000

//	    mwm SW_irq
//00B5
1303

//	//     // Software prescale gets upper 8 bits
//	//     sw_prescale = (*SW >> 8) & 0xff;
//
//	    mm SW,w
//00B6
0300

//	    mwm sw_prescale
//00B7
1004

//	    rrm sw_prescale,m
//00B8
4804

//	    rrm sw_prescale,m
//00B9
4804

//	    rrm sw_prescale,m
//00BA
4804

//	    rrm sw_prescale,m
//00BB
4804

//	    rrm sw_prescale,m
//00BC
4804

//	    rrm sw_prescale,m
//00BD
4804

//	    rrm sw_prescale,m
//00BE
4804

//	    rrm sw_prescale,m  // everything rotated in is in upper 8 bits
//00BF
4804

//	    mlw 0xff
//00C0
20FF

//	    awm sw_prescale,m  // which gets masked out, so don't need to clear carry
//00C1
5804

//	                       // for logical shift
//
//	//     // Timer periph prescale gets lower 8 bits
//	//     *TIMER_0_control =
//	//         (*TIMER_0_control & (~TMR0_CTL_PRE_MASK)) | ((*SW & 0xff) << 8);
//	//   }
//	// optimized => IRQ_TEMP0 = TIMER_0_control & 0xff
//	// optimized => IRQ_TEMP1 = ((*SW & 0xff) << 8) => (*SW << 8) & 0xff00
//	// optimized => TIMER_0_control = IRQ_TEMP0 | IRQ_TEMP1
//	    mm TIMER_0_control,w
//00C2
030A

//	    mwm IRQ_TEMP0
//00C3
1008

//	    mlw 0x0ff
//00C4
20FF

//	    awm IRQ_TEMP0,m
//00C5
5808

//	    mm SW,w
//00C6
0300

//	    mwm IRQ_TEMP1
//00C7
1009

//	    rlm IRQ_TEMP1,m
//00C8
3809

//	    rlm IRQ_TEMP1,m
//00C9
3809

//	    rlm IRQ_TEMP1,m
//00CA
3809

//	    rlm IRQ_TEMP1,m
//00CB
3809

//	    rlm IRQ_TEMP1,m
//00CC
3809

//	    rlm IRQ_TEMP1,m
//00CD
3809

//	    rlm IRQ_TEMP1,m
//00CE
3809

//	    rlm IRQ_TEMP1,m  // lower bits that are rotated in get masked
//00CF
3809

//	    mlw -256  // 0xff00 => 0x700, sign ext => -256
//00D0
2700

//	    awm IRQ_TEMP1,w
//00D1
5009

//	    owm IRQ_TEMP0,w
//00D2
6008

//	    mwm TIMER_0_control
//00D3
130A

//	// }
//
//	__IRQ_RESTORE:
//00D4

//	// RESTORE STATE and Return from interrupt
//	    mm IRQ_SAVE_INDA,w
//00D4
0007

//	    mwm INDA  // Restore INDA
//00D5
1204

//	    rrm IRQ_SAVE_ZC,m  // rotate carry back to its position
//00D6
4806

//	    mm IRQ_SAVE_WREG,w  // restore WREG
//00D7
0005

//	    mm IRQ_SAVE_ZC,m  // restore ZERO
//00D8
0806

//	    rfi
//00D9
FFFF
